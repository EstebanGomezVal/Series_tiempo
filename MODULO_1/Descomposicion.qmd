---
title: "Descomposicion"
author: "Esteban Gomez"
format: html
editor: visual
---

```{r}
library(tidyverse)
library(fpp3)
```
La funcion 'model()' sirve para ajustar uno o mas modelos a la(s) serie(s) de tiempo. Nos devuelve una tabla de modelos ('mable').

```{r}
tasmania <- tourism |> 
  filter(State == "Tasmania",
         Region == "East Coast")

tasmania
```

```{r}
tasmania |> 
  model(classical_decomposition(Trips, type = "additive")) |>
  components() |> 
  autoplot() +
  theme(legend.position = "bottom")
```

```{r}
tasmania |> 
  model(classical_decomposition(Trips, type = "additive")) |>
  components() |> 
  filter(Purpose == "Holiday") |> 
  autoplot()
```

```{r}
tasmania |> 
  model(classical_decomposition(Trips, type = "additive")) |>
  components() |> 
  filter(Purpose == "Holiday") |> 
  autoplot()

tasmania |> 
  model(classical_decomposition(Trips, type = "additive")) |>
  components() |> 
  filter(Purpose == "Business") |> 
  autoplot()

tasmania |> 
  model(classical_decomposition(Trips, type = "additive")) |>
  components() |> 
  filter(Purpose == "Visiting") |> 
  autoplot()

tasmania |> 
  model(classical_decomposition(Trips, type = "additive")) |>
  components() |> 
  filter(Purpose == "Other") |> 
  autoplot()
```

```{r}
aus_production |> 
  autoplot(Gas)
aus_production |> 
  model(classical_decomposition(Gas, type = "multiplicative")) |> 
  components() |> 
  autoplot()
```

La función `model()` sirve para ajustar uno o más modelos a la(s) serie(s) de tiempo. Nos devuelve una tabla de modelos (`mable`).

```{r}
tasmania_comp <- tasmania |> 
  model(
    dcmp_clasica = classical_decomposition(Trips)
  ) |> 
  components()

tasmania_comp

tasmania_comp |> 
  autoplot()
```

```{r}
tasmania_comp |> 
  filter(Purpose == "Holiday") |> 
  ggplot(aes(x = Quarter, y = Trips)) +
  geom_line(color = "grey", size = 2) +
  geom_line(aes(y = season_adjust), color = "dodgerblue", size = 2)
```

```{r}
aus_production |> 
  model(STL(Gas, robust = TRUE)) |> 
  components() |> 
  ggplot(aes(x = Quarter, y = Gas)) +
  geom_line(color = "grey", size = 1) +
  geom_line(aes(y = trend), color = "firebrick", size = 1)

aus_production |> 
  model(STL(Gas, robust = TRUE)) |> 
  components() |> 
  ggplot(aes(x = Quarter, y = Gas)) +
  geom_line(color = "grey", size = 1) +
  geom_line(aes(y = season_adjust), color = "dodgerblue", size = 1)
```

## Descomposicion STL

```{r}
tasmania |>
  filter(Purpose == "Holiday") |>
  model(
    STL(Trips ~ trend(window = 11) + season(window = "periodic"), robust = TRUE)
        ) |>
      components() |>
      autoplot()
```

### Graficas

Grafica de tiempo
```{r}
aus_production |>
  autoplot(Gas)

```

Graficas estacionales

```{r}
aus_production |>
  gg_season(Gas) #estacionalidad a lo largo de los años
```

Grafica de subseries 

```{r}
aus_production |>
  gg_subseries(Gas)
```

```{r}
aus_production |>
  gg_tsdisplay(Gas)
```

Ingenuo estacional - Repites por estacionalidad el valor hacia el futuro

Metodo ingenuo: Toma el ultimo valor para todo lo que sigue

Modelo de la media - Simplemente sacas la media y lo colocas en todos los dias que siguen

Drift (Deriva) - Toma primer y ultimo valor y traza una linea recta

### Benchmark models
```{r}
gas_fit <- aus_production |>
  model(
    media = MEAN(Gas),
    naive = NAIVE(Gas),
    seasonal_naive = SNAIVE(Gas),
    drift = NAIVE(Gas ~ drift())
  )

gas_fit
```
```{r}
gas_aug <- gas_fit |>
  augment()
gas_aug

gas_aug |>
  autoplot(.innov) +
  facet_wrap(vars(.model), scale = "free_y") +
  theme(legend.position = "none")

gas_aug |>
  group_by_key() |>
  as_tibble() |>
  summarise(media = mean(.resid, na.rm = TRUE))
```

```{r}
#| warning: FALSE
gas_fit |>
  select(naive) |>
  gg_tsresiduals()
```
1. No autocorrelacion: Relacion de lo actual depende de lo de antes.
2. Media cero: 
3. Varianza constante
4. Distr. normal

```{r}
#| warning: false
gas_fit |>
  select(seasonal_naive) |>
  gg_tsresiduals()
```

**Test de Box-Pierce**

T = Total de periodos
$r_k$ = k-esimo coeficiente de correlacion
m = periodo estacional

$$
Q = T \sum_{k=1}^h r_k^2
$$
Se sugiere utilizar h=10 sin estacionalidad, h=2*m con estacionalidad h <= $\frac{T}{5}$

Si Q=0, no hay correlacion, Ruido blanco

Si Q diferente de 0, Autocorrelacion


**Test de Ljung-Box**
$$
Q = T(T+2) \sum_{k=1}^{h} (T-k)^{-1} \cdot r_k^2
$$
P-value: Probabilidad exacta de cometer un error tipo I(Falso positivo)
$\alpha$ = Nivel de significacncia (Nivel maximo para tolerar de error)
$1-\alpha$ = Nivel de confianza

p-value < $\alpha$ Rechazo $H_0$
p-value > $\alpha$ No rechazo $H_0$

Si rechazo hipotesis nula, significativamente existe correlacion

```{r}
gas_aug |>
  features(.innov, box_pierce, lag = 8)
```

```{r} 
gas_fit |> 
  forecast(h = "2 years") |> 
  autoplot(aus_production) +
  facet_wrap(vars(.model), scales = "free_y")
```

```{r}
gas_fit2 <- aus_production |>
  model(
    stlf = decomposition_model(
      #especificar la descomposición
      STL(log(Gas) ~ season(window = "periodic"), robust = TRUE),
      #especificamos el modelo para la estacionalidad
      SNAIVE(season_year),
      RW(season_adjust ~ drift())
      ),
    stlf2 = decomposition_model(
      #especificar la descomposición
      STL(log(Gas) ~ season(window = "periodic"), robust = TRUE),
      #Si no especifica como modelar la estacionalidad, se toma SNAIVE por default
      NAIVE(season_adjust)
      )
    )
gas_fit2
```

```{r}
#| Warning = false
gas_fit2 |>
  select(stlf) |>
  gg_tsresiduals()

gas_fit2 |>
  select(stlf2) |>
  gg_tsresiduals()

gas_fit2 |>
  augment() |>
  features(.innov, ljung_box, lag = 8)

```

```{r}
gas_fit2 |> 
  forecast(h = "5 years") |> 
  autoplot(aus_production, level = NULL)
```

```{r}
gas_train <- aus_production |>
  filter_index(. ~ "2005 Q2")

gas_fit2 <- gas_train |>
  model(
    stlf = decomposition_model(
      #especificar la descomposición
      STL(log(Gas) ~ season(window = "periodic"), robust = TRUE),
      #especificamos el modelo para la estacionalidad
      SNAIVE(season_year),
      RW(season_adjust ~ drift())
      ),
    stlf2 = decomposition_model(
      #especificar la descomposición
      STL(log(Gas) ~ season(window = "periodic"), robust = TRUE),
      #Si no especifica como modelar la estacionalidad, se toma SNAIVE por default
      NAIVE(season_adjust)
      )
    )

gas_fit2 
```

Errores dependientes de escalas:

MAE = mean$|e_k|$
RMSE = $\sqrt{mean(e_k^2)}$

Errores Porcentuales:
MAPE = $mean(|p_k|)$ = $\frac{|y_k - y^l_k|}{y_k}$

Errores escalados:

- Para series no estacionales

- Para series estacionales

MASE = mean$|q_j|$
RMSSE = $\sqrt{mean(q_j^2)}$

## Combinacion de modelos

```{r}
gas_fit3 <- gas_fit2 |>
  mutate(
    stl_combinado = (stlf + stlf2)/2
  )
gas_fit3
```

